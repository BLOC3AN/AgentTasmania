services:
  # AI Core Agent Service
  ai-core:
    build:
      context: ./AI_core
      dockerfile: Dockerfile
    container_name: service-ai-core
    ports:
      - "8000:8000"
    environment:
      - API_PORT=8000
      - MCP_SERVER_URL=http://mcp-server:8001
      - DATABASE_URL=http://vectordb:8002
    env_file:
      - .env
    networks:
      - agent-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # MCP Server Service
  mcp-server:
    build:
      context: ./MCP_server
      dockerfile: Dockerfile
    container_name: service-mcp-server
    ports:
      - "8001:8001"
    environment:
      - API_PORT=8001
      - DATABASE_URL=http://vectordb:8002
    env_file:
      - .env
    networks:
      - agent-network
    restart: unless-stopped

  # Embedding Service
  embedding:
    build:
      context: ./embedding_service
      dockerfile: Dockerfile
    container_name: embedding
    ports:
      - "8005:8005"
    environment:
      - API_PORT=8005
      - MODEL_CACHE_DIR=/app/models
    env_file:
      - .env
    networks:
      - agent-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8005/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 120s

  # Database Service (Postgres + Qdrant)

  vectordb:
    build:
      context: ./database_service
      dockerfile: Dockerfile
    container_name: service-vectordb
    ports:
      - "8002:8002"
    environment:
      - API_PORT=8002
      - EMBEDDING_SERVICE_URL=http://embedding:8005
      - QDRANT_URL=http://qdrant:6333
    env_file:
      - .env
    networks:
      - agent-network
    restart: unless-stopped


  # WebSocket Service
  websocket:
    build:
      context: ./websocket_service
      dockerfile: Dockerfile
    container_name: service-websocket
    ports:
      - "8003:8003"
    environment:
      - API_PORT=8003
      - MCP_API_URL=http://mcp-server:8001
    env_file:
      - .env
    networks:
      - agent-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8003/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Frontend Service
  frontend:
    build:
      context: ./frontend_service
      dockerfile: Dockerfile.dev
    container_name: service-frontend
    ports:
      - "3000:3000"
    volumes:
      # Mount source code for development hot reload
      - ./frontend_service/src:/app/src:ro
      - ./frontend_service/public:/app/public:ro
      - ./frontend_service/package.json:/app/package.json:ro
      - ./frontend_service/next.config.ts:/app/next.config.ts:ro
      - ./frontend_service/tsconfig.json:/app/tsconfig.json:ro
      - ./frontend_service/postcss.config.mjs:/app/postcss.config.mjs:ro
      - ./frontend_service/eslint.config.mjs:/app/eslint.config.mjs:ro
      # Exclude node_modules to avoid conflicts
      - /app/node_modules
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:8000
      - NEXT_PUBLIC_WEBSOCKET_URL=ws://localhost:8003
    networks:
      - agent-network
    restart: unless-stopped
    depends_on:
      - ai-core
      - websocket

  
  # Database Service (Postgres)
  postgres:
    image: postgres:15
    container_name: postgres
    ports:
      - "5433:5432"
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: Hai@30032000
      POSTGRES_DB: mydb
    # Optional: Redis for caching (future use)
    
  redis:
    image: redis:7-alpine
    container_name: redis
    ports:
      - "6389:6379"
    volumes:
      - ../data/redis:/data
    restart: unless-stopped
    networks:
      - agent-network
    command: redis-server --appendonly yes

  qdrant:
    image: qdrant/qdrant:latest
    container_name: qdrant
    restart: always
    ports:
      - "6333:6333" # For REST API
      - "6334:6334" # For gRPC
    expose:
      - 6333 # For REST API
      - 6334 # For gRPC
      - 6335 # For internal communication
    volumes:
      - ./data/qdrant:/qdrant/storage
    networks:
      - agent-network

  dozzle:
    container_name: dozzle-agent-education
    image: amir20/dozzle:latest
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - "5555:5555"
    environment:
      - DOZZLE_LEVEL=info
      - DOZZLE_TAILSIZE=300
      - DOZZLE_AUTH=false
    command: ["--addr=:5555"] 
    restart: unless-stopped
    networks:
      - agent-network

  # Monitor Service:
  monitor:
    build:
      context: ./monitor_service
      dockerfile: Dockerfile
    container_name: service-monitor
    ports:
      - "8004:8004"
    environment:
      - API_PORT=8004
      - AI_CORE_URL=http://ai-core:8000
      - MCP_SERVER_URL=http://mcp-server:8001
      - DATABASE_URL=http://vectordb:8002
      - WEBSOCKET_URL=http://websocket:8003
      - EMBEDDING_URL=http://embedding:8005
    networks:
      - agent-network
    restart: unless-stopped

  # Text-to-Speech Service
  tts:
    build:
      context: ./text-to-speech
      dockerfile: Dockerfile
    container_name: service-tts
    ports:
      - "8007:8007"
    environment:
      - API_PORT=8007
    env_file:
      - ./text-to-speech/.env
    networks:
      - agent-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8007/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # ASR WebSocket Service (COMMENTED OUT FOR TESTING)
  # asr:
  #   build:
  #     context: ./ASR_service/server_process_GPU
  #     dockerfile: Dockerfile
  #   container_name: asr-service
  #   environment:
  #     - API_PORT=8006
  #   ports:
  #     - "8006:8006"
  #   networks:
  #     - agent-network
  #   restart: unless-stopped
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:8006/health"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 60s


networks:
  agent-network:
    driver: bridge

volumes:
  logs:
    driver: local
